from typing import Optional

"""
    红黑树是 AVL 树的一种变种,对红黑树操作在最坏的情况下
    花费 O(logN) 时间, 对于插入操作,一种非递归实现可以相对容易地完成(与 AVL 树相比)

    红黑树的性质:
    1. 每个节点或者红色或者黑色
    2. 根是黑色
    3. 如果一个节点是红色, 那么它的子节点必须是黑色
    4. 从一个节点到 NULL 指针的每一条路径必须包含相同数目的黑色节点
    约定: NULL 节点为黑色(这个约定似乎除了增加理解的难度之外没有用处?)
    
    这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于
    最短的可能路径的两倍长 (因为第四条约束, 红黑树不能一直朝一个方向延伸
    ,如果红黑树一直朝一个方向延伸, 那么根节点到 NULL 指针的黑色节点数目必然不同
    ,除新节点都为红色节点, 但第三条约束保证不能有连续的红节点)
    
    着色法则的一个推论是, 红黑树的高度最多是 2log(N+1), 因此保证
    查找是一种对数的操作(证明见 WIKI)
    
    红黑树叶子节点有下面两种情况:
    1. 
        黑
      红  红  
    红节点的子节点个数为 [0,2]
    
    2.  ?
     黑    黑
     
插入有两种方案: 
    1. 插入黑色放到树叶中, 情形 1,2 都会与红黑树着色规则冲突,也就是插入一次需要调整一次
    2. 插入红色放到树叶中, 父节点是红色的情况需要调整(旋转,重新着色)
    选择方案 2
    
插入的情况:
1. 父节点为黑色, 直接插入

=============
2. 父节点为红色, 叔父节点不存在(或为黑色),当 new 为新节点时, 黑色叔父节点必然不存在, 
当 new 上滤(情形3)过程中变色的节点时, 叔父节点可以为黑色

2.1.1 插入父节点左边(N 为新节点):

      黑(G)
   红(P)          
红(N)


左旋转后 -> :


    黑(p)
红(N)   红(G)

=============
2.1.2 插入父节点左边(N 为上滤变色的节点)
      黑(G)
   红(P)     R1       
红(N)  R2

左旋转后 -> : 
    
    黑(p)
红(N)   红(G)
       R2   R1

可以发现 2.1.1 就是 2.1.2 的一种情况
=============
2.2.1 插入父节点右边(N 为新节点):
      黑(G)
   红(P)             
     红(N)

以 P 节点为根进行右旋转 ->:
      黑(G)
   红(N)           
红(P)

回到了情况 2.1.1, 再次进行左旋转即可


=============
2.2.1 插入父节点右边(N 为上滤变色的节点):
        黑(G)
   红(P)       R1         
R2    红(N)

以 P 节点为根进行右旋转 ->:
              黑(G)
         红(N)      R1      
    红(P)
 R2

现在回到了情况 2, 再次进行左旋转 ->:
    
         黑(N)
  红(P)         红(G)
R2    R1            R1

可以发现 2.2.1 就是 2.2.2 的一种情况
=============
3. 父节点为红色, 叔父节点为红色
        黑(G)
    红(P)    红(S)
红(NEW)

三个红色节点,一个黑色节点,
必需将根涂成红色来保证符合红黑树特性, 根变成红色,如果根的父节点
为红色,那么需要上滤,直到没有两个连续红色节点

-> 

        红(G)
    黑(P)    黑(S)
红(NEW)

上滤过程中,可能会遇到情况 2, 也可能遇到情况 3
"""


class Node:
    def __init__(
            self, val: int,
            left: Optional['Node'] = None,
            right: Optional['Node'] = None,
            red: bool = True
    ):
        self.val: int = val
        self.left: Optional['Node'] = left
        self.right: Optional['Node'] = right
        self.red: bool = red


class RBTree:
    def __init__(self):
        self.root: Optional[Node] = None

    def insert(self, val: int):
        pass

    def delete(self, val: int):
        pass

    def find(self, val: int) -> Optional[Node]:
        pass

    def valid(self, val) -> bool:
        pass

    def __bool__(self) -> bool:
        return self.root is not None
